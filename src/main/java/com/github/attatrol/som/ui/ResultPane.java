
package com.github.attatrol.som.ui;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

import com.github.attatrol.preprocessing.datasource.AbstractTokenDataSource;
import com.github.attatrol.preprocessing.datasource.Record;
import com.github.attatrol.preprocessing.datasource.parsing.TokenType;
import com.github.attatrol.preprocessing.ui.TokenDataSourceAndMisc;
import com.github.attatrol.preprocessing.ui.TokenDataSourceTableView;
import com.github.attatrol.preprocessing.ui.misc.UiUtils;
import com.github.attatrol.som.som.Som;
import com.github.attatrol.som.som.SomClusterResult;
import com.github.attatrol.som.som.initializers.SampleFrequencyCalculator;
import com.github.attatrol.som.som.neuron.AbstractNeuron;
import com.github.attatrol.som.som.topology.Point;
import com.github.attatrol.som.ui.i18n.SomI18nProvider;
import com.github.attatrol.som.ui.utils.RamTokenDataSource;

import javafx.scene.chart.Chart;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.stage.Screen;

/**
 * Pane that shows result of your trained SOM.
 * 
 * @author atta_troll
 *
 */
public class ResultPane extends GridPane {

    /**
     * Max number of neurons to be shown in table view
     */
    private static final int SHOWN_NUMBER_OF_NEURONS = 2500;

    /**
     * Minimal color brightness for a tile.
     */
    private static final double MIN_COLOR_LEVEL = 0.1;

    /**
     * Maximal brightness for a tile.
     */
    private static final double MAX_COLOR_LEVEL = 1.0;

    /**
     * Minimal brightness for a populated (non-empty) tile.
     */
    private static final double MIN_POPULATED_COLOR_LEVEL = 0.3;

    /**
     * Number of bars in charts generated by {@link NumericalColorScheme}.
     */
    private static final int NUMERIC_BAR_CHART_BAR_NUMBER = 15;

    /*
     * Internal state.
     */
    /**
     * Token data source associated with this SOM.
     */
    private final TokenDataSourceAndMisc tdsm;

    /**
     * Result of cluster process of all data with the SOM.
     */
    private final SomClusterResult clusterResult;

    /**
     * Cache for neuron associated data sources.
     */
    private final Map<AbstractNeuron, AbstractTokenDataSource<?>> neuronDataSources = new WeakHashMap<>();

    /**
     * Cache for table views.
     */
    private final Map<AbstractNeuron, TokenDataSourceTableView> tableViews = new WeakHashMap<>();

    /*
     * UI controls.
     */
    /**
     * Current table view.
     */
    private TokenDataSourceTableView currentTableView;

    /**
     * Current bar chart.
     */
    private Chart currentBarChart;

    /**
     * Resets table to very first records.
     */
    private Button reloadTableViewButton = new Button(SomI18nProvider
            .INSTANCE.getValue("result.button.table.reload"));
    {
        reloadTableViewButton.setOnAction(ev -> {
            if (currentTableView != null) {
                currentTableView.reloadView();
                currentTableView.loadNext();
            }
        });
    }

    /**
     * Loads next records.
     */
    private Button loadNextTableViewButton = new Button(
            String.format(SomI18nProvider.INSTANCE.getValue("result.button.table.loadnext"),
                    TokenDataSourceTableView.DEFAULT_SHOWN_RECORD_NUMBER));
    {
        loadNextTableViewButton.setOnAction(ev -> {
            if (currentTableView != null) {
                currentTableView.loadNext();
            }
        });
    }

    /**
     * Check box with different options for tiles coloring
     */
    private ComboBox<ColorScheme> colorCheckBox;

    /**
     * Currently chosen som tile.
     */
    private SomTile chosenSomTile;

    /**
     * Default ctor
     * @param tdsm token data source with metadata
     * @param clusterResult result of clustering
     * @param som trained SOM
     */
    public ResultPane(TokenDataSourceAndMisc tdsm, SomClusterResult clusterResult, Som som) {
        super();
        this.tdsm = tdsm;
        this.clusterResult = clusterResult;
        final List<AbstractNeuron> neurons = som.getNeurons();
        final List<SomTile> tiles = new ArrayList<>();
        neurons.forEach(neuron -> tiles.add(new SomTile(neuron)));
        final Pane tilePane = new Pane();
        placeTiles(tilePane, tiles);
        add(tilePane, 0, 0, 3, 1);
        GridPane.setHgrow(tilePane, Priority.NEVER);
        GridPane.setVgrow(tilePane, Priority.NEVER);
        colorCheckBox = new ColorComboBox(tdsm, tiles);
        //TODO i'm lazy and sure there is a better way of scaling
        tilePane.setPrefWidth(Screen.getPrimary().getVisualBounds().getWidth() / 2.);
        tilePane.setPrefHeight(Screen.getPrimary().getVisualBounds().getHeight() / 2.);
        setPrefWidth(Screen.getPrimary().getVisualBounds().getWidth() / 1.5);
        setPrefHeight(Screen.getPrimary().getVisualBounds().getHeight() - 25.);
        add(reloadTableViewButton, 0, 1);
        add(loadNextTableViewButton, 1, 1);
        add(colorCheckBox, 2, 1);
        colorCheckBox.getSelectionModel().select(0);
        add(new Label(String.format(SomI18nProvider.INSTANCE.getValue("result.label.table.info"),
                SHOWN_NUMBER_OF_NEURONS)), 0, 2, 3, 1);
    }

    /**
     * Getter for a column name.
     * @param i column index (Index column omitting)
     * @param titles original titles set
     * @return title for a current column
     */
    public static String getColumnName(int i, String[] titles) {
        if (titles != null && titles.length > i && titles[i] != null) {
            return titles[i];
        }
        else {
            return TokenDataSourceTableView.getStubColumnName(i);
        }
    }

    /**
     * Places tiles onto tile pane.
     * @param tilePane tile pane
     * @param tiles tiles
     */
    private void placeTiles(Pane tilePane, List<SomTile> tiles) {
        double xMin = 0;
        double xMax = 0;
        double yMin = 0;
        double yMax = 0;
        Iterator<SomTile> iterator = tiles.iterator();
        if (iterator.hasNext()) {
            final Point point = iterator.next().getPosition();
            xMin = point.getX();
            xMax = point.getX();
            yMin = point.getY();
            yMax = point.getY();
        }
        while (iterator.hasNext()) {
            final Point point = iterator.next().getPosition();
            final double x = point.getX();
            final double y = point.getY();
            if (x < xMin) {
                xMin = x;
            }
            if (x > xMax) {
                xMax = x;
            }
            if (y < yMin) {
                yMin = y;
            }
            if (y > yMax) {
                yMax = y;
            }
        }
        final double xRange = xMax - xMin + 1.;
        final double yRange = yMax - yMin + 1.;
        for (SomTile tile : tiles) {
            final Point point = tile.getPosition();
            final double x = point.getX();
            final double y = point.getY();
            tile.xProperty().bind(tilePane.widthProperty().multiply(x - xMin).divide(xRange));
            tile.yProperty().bind(tilePane.heightProperty().multiply(y - yMin).divide(yRange));
            tile.heightProperty().bind(tilePane.heightProperty().divide(yRange));
            tile.widthProperty().bind(tilePane.widthProperty().divide(xRange));
            tilePane.getChildren().add(tile);
            tile.setTilePane(tilePane);
        }
    }

    /**
     * A single rectangular SOM tile.
     * @author atta_troll
     *
     */
    private class SomTile extends Rectangle {

        /**
         * FuzzyNeuron associated with this tile.
         */
        private final AbstractNeuron neuron;

        /**
         * Pane where this tile is placed.
         */
        private Pane tilePane;

        /**
         * Chart with frequencies.
         */
        private Chart chart;

        /**
         * Lines used to for cross on this rectangle.
         */
        private Line crossLine1 = new Line(getX(), getY(), getX() + getWidth(), getY() + getHeight());
        private Line crossLine2 = new Line(getX() + getWidth(), getY(), getX(), getY() + getHeight());
        {
            crossLine1.setStroke(ColorUtils.LINE_COLOR);
            crossLine2.setStroke(ColorUtils.LINE_COLOR);
            crossLine1.setStrokeWidth(2.);
            crossLine2.setStrokeWidth(2.);
            crossLine1.startXProperty().bind(xProperty());
            crossLine1.startYProperty().bind(yProperty());
            crossLine1.endXProperty().bind(xProperty().add(widthProperty()));
            crossLine1.endYProperty().bind(yProperty().add(heightProperty()));
            crossLine2.startXProperty().bind(xProperty().add(widthProperty()));
            crossLine2.startYProperty().bind(yProperty());
            crossLine2.endXProperty().bind(xProperty());
            crossLine2.endYProperty().bind(yProperty().add(heightProperty()));
        }

        SomTile(AbstractNeuron neuron) {
            this.neuron = neuron;
            this.setStrokeWidth(2.);
            setStroke(ColorUtils.LINE_COLOR);
            setOnMouseClicked(ev -> {
                showTableView();
                showChart();
                if (chosenSomTile != null) {
                    chosenSomTile.setNotChosen();
                }
                chosenSomTile = this;
                setChosen();
            });
        }

        public void setTilePane(Pane tilePane) {
            this.tilePane= tilePane;
        }

        public Point getPosition() {
            return neuron.getPosition();
        }

        public long getSize() {
            return clusterResult.getClusterSize(neuron);
        }

        public void setNotChosen() {
            tilePane.getChildren().remove(crossLine1);
            tilePane.getChildren().remove(crossLine2);
        }

        public void setChosen() {
            tilePane.getChildren().add(crossLine1);
            tilePane.getChildren().add(crossLine2);
        }

        /**
         * Copies all records that belong to this neuron into ram data source.
         * Stores this data source into cache.
         * @param neuron
         * @return
         * @throws IOException
         */
        public AbstractTokenDataSource<?> getTileDataSource ()
                throws IOException {
            AbstractTokenDataSource<?> ramDataSource = neuronDataSources.get(neuron);
            if (ramDataSource == null) {
                final AbstractTokenDataSource<?> originalDataSource = tdsm.getTokenDataSource();
                final List<Record<Object[]>> records = clusterResult.getClusterRecords(
                        originalDataSource, neuron, SHOWN_NUMBER_OF_NEURONS);
                ramDataSource = RamTokenDataSource
                        .getClusterRamTokenSource(records, originalDataSource.getRecordLength());
                neuronDataSources.put(neuron, ramDataSource);
            }
            return ramDataSource;
        }

        /**
         * Sets new chart to the tile.
         * @param chart chart with info
         */
        public void setChart(Chart chart) {
            this.chart = chart;
        }

        /**
         * Shows chart of current tile in UI.
         */
        public void showChart() {
            if (currentBarChart == chart) {
                return;
            }
            else {
                if (currentBarChart != null) {
                    getChildren().remove(currentBarChart);
                }
                currentBarChart = chart;
                if (chart != null) {
                    add(chart, 5, 0);
                }
            }
        }

        /**
         * Sets new visible table view.
         * @param neuron neuron which content is to be shown
         */
        private void showTableView() {
            TokenDataSourceTableView newTableView = tableViews.get(neuron);
            try {
                if (newTableView == null) {
                    newTableView = produceNewTableView();
                    tableViews.put(neuron, newTableView);
                }
                if (newTableView != currentTableView) {
                    if (currentTableView != null) {
                        getChildren().remove(currentTableView);
                    }
                    currentTableView = newTableView;
                    add(newTableView, 0, 3, 6, 1);
                    newTableView.reloadView();
                    newTableView.loadNext();
                }
            }
            catch (IOException ex) {
                UiUtils.showExceptionMessage(ex);
            }
        }

        /**
         * Produces new table view for a neuron.
         * @param neuron neuron
         * @return table with records associated with the neuron
         * @throws IOException on data source i/o error
         */
        private TokenDataSourceTableView produceNewTableView()
                throws IOException {
            final TokenDataSourceTableView tableView =
                    new TokenDataSourceTableView(getTileDataSource(),
                            tdsm.getTitles());
            return tableView;
        }

        @Override
        public int hashCode() {
            return neuron.hashCode();
        }
    }

    /**
     * Color scheme that can be applied to the tiles.
     * @author atta_troll
     *
     */
    abstract class ColorScheme {

        protected String name;

        protected Map<SomTile, Color> colorScheme = new HashMap<>();

        protected Map<SomTile, Chart> charts = new HashMap<>();

        public void applyColorScheme() {
            colorScheme.forEach((key, value) -> key.setFill(value));
            charts.forEach((key, value) -> key.setChart(value));
            if (chosenSomTile != null) {
                chosenSomTile.showChart();
            }
        }

        @Override
        public String toString() {
            return name;
        }
    }

    /**
     * Single color scheme based on number of records assigned to the tile
     *
     */
    public class QuantityColorScheme extends ColorScheme {

        public QuantityColorScheme(List<SomTile> tiles) {
            name = SomI18nProvider.INSTANCE.getValue("result.color.scheme.quantity");
            long maxSize = 0L;
            long minSize = 0L;
            Iterator<SomTile> iterator = tiles.iterator();
            if (iterator.hasNext()) {
                final long size = iterator.next().getSize();
                maxSize = size;
                minSize = size;
            }
            while (iterator.hasNext()) {
                final long size = iterator.next().getSize();
                if (maxSize < size) {
                    maxSize = size;
                }
                else if (minSize > size) {
                    minSize = size;
                }
            }
            final long range = maxSize - minSize;
            for (SomTile tile : tiles) {
                final long size = tile.getSize();
                final double colorLevel;
                if (size == 0L) {
                    colorLevel = MIN_COLOR_LEVEL;
                }
                else {
                    colorLevel = ((double) (size - minSize)) / range * (MAX_COLOR_LEVEL
                            - MIN_POPULATED_COLOR_LEVEL) + MIN_POPULATED_COLOR_LEVEL;
                }
                charts.put(tile, null);
                colorScheme.put(tile, Color.color(0., colorLevel, 0.));
            }
        }
        
    }

    /**
     * Token color scheme for categorical token
     *
     */
    class CategoricalColorScheme extends ColorScheme {

        public CategoricalColorScheme(List<SomTile> tiles,
                Map<Object, Color> colorMap, Map<SomTile, Map<Object, Double>> tileFrequencies,
                String name) throws IOException {
            this.name = name;
            for (SomTile tile : tiles) {
                Object mft = getMostFrequentToken(tileFrequencies.get(tile));
                Color color;
                if (mft == null) {
                    color = ColorUtils.DEAD_NEURON_COLOR;
                }
                else {
                    color = colorMap.get(mft);
                    if (color == null) {
                        color = ColorUtils.OTHER_TILE_COLOR;
                    }
                    charts.put(tile, new SomTileBarChart(tileFrequencies.get(tile)));
                }
                colorScheme.put(tile, color);
            }
        }

        private Object getMostFrequentToken(Map<Object, Double> tileFrequencies) {
            Double frequency = 0.;
            Object mft = null;
            for (Map.Entry<Object, Double> entry : tileFrequencies.entrySet()) {
                if (entry.getValue() > frequency) {
                    mft = entry.getKey();
                    frequency = entry.getValue();
                }
            }
            return mft;
        }
        
    }

    /**
     * Token color scheme for numerical token, uses color temperature to represent values of token.
     *
     */
    class NumericalColorScheme extends ColorScheme {

        public NumericalColorScheme(List<SomTile> tiles, int i, double min, double max,
                TokenType type, String name) throws IOException {
            this.name = name;
            final double range = max - min != 0. ? max - min : 1.;
            final int bucketNumber = range == 0. ? 1 : NUMERIC_BAR_CHART_BAR_NUMBER;
            double[] thresholds = new double[bucketNumber];
            for (int j = 0; j < bucketNumber; j++) {
                thresholds[j] = min + range * j / bucketNumber;
            }
            for (SomTile tile : tiles) {
                double[] buckets = new double[bucketNumber];
                AbstractTokenDataSource<?> tileDataSource = tile.getTileDataSource();
                double accumulator = 0.;
                long counter = 0L;
                tileDataSource.reset();
                while (tileDataSource.hasNext()) {
                    Object token = tileDataSource.next().getData()[i];
                    double summand = 0.;
                    if (type == TokenType.INTEGER) {
                        summand = (Integer) token;
                    }
                    else if (type == TokenType.FLOAT) {
                        summand = (Double) token;
                    }
                    accumulator += summand;
                    counter++;
                    boolean lastBucket = true;
                    for (int j = 0; j < bucketNumber - 1; j++) {
                        if (summand < thresholds[j + 1]) {
                            buckets[j] += 1.;
                            lastBucket = false;
                            break;
                        }
                    }
                    if (lastBucket) {
                        buckets[bucketNumber - 1] += 1.;
                    }
                }
                if (counter == 0L) {
                    colorScheme.put(tile, ColorUtils.DEAD_NEURON_COLOR);
                }
                else {
                    for (int j = 0; j < bucketNumber; j++) {
                        buckets[j] /= counter;
                    }
                    charts.put(tile, new SomTileNumericChart(buckets, thresholds, range / bucketNumber));
                    colorScheme.put(tile, ColorUtils
                            .getHeatMapColor((accumulator / counter - min) / range));
                }
                
            }
        }

    }

    /**
     * Combo box used to switch between color schemes
     * @author atta_troll
     *
     */
    class ColorComboBox extends ComboBox<ColorScheme> {

        /**
         * Default ctor
         * @param schemes
         */
        private ColorComboBox(TokenDataSourceAndMisc tdsm, List<SomTile> tiles) {
            this.getItems().addAll(produceColorSchemes(tdsm, tiles));
            this.valueProperty().addListener((observable, oldValue,newValue)
                    -> newValue.applyColorScheme());
        }


        /**
         * Factory method for all color schemes. It generates all color schemes.
         * It doesn't throw exception because of use incide of ctor of this pane, however,
         * in case of i/o error message will be shown.
         * @param tdsm token data source
         * @param tiles tiles
         */
        private List<ColorScheme> produceColorSchemes(TokenDataSourceAndMisc tdsm, List<SomTile> tiles) {
            final int recordLength = tdsm.getTokenDataSource().getRecordLength();
            final TokenType[] tokenTypes = tdsm.getTokenTypes();
            final String[] titles = tdsm.getTitles();
            final List<ColorScheme> schemes = new ArrayList<ColorScheme>();
            schemes.add(new QuantityColorScheme(tiles));
            try {
                Map<Object, Color>[] tokenColorsByFrequency = ColorUtils.getTokenColorsByFrequency(tdsm);
                Map<SomTile, Map<Object, Double>>[] tileFrequencies =
                        getTileFrequencies(tiles, recordLength, tokenTypes);
                SampleFrequencyCalculator.MinAndMax[] bounds =
                        SampleFrequencyCalculator.getNumericTokenBounds(
                        tdsm.getTokenDataSource(), tokenTypes);
                for (int i = 0; i < recordLength; i++) {
                    try {
                        ColorScheme scheme = null;
                        if (SampleFrequencyCalculator.isCategoricalTokenType(tokenTypes[i])) {
                            scheme = new CategoricalColorScheme(tiles, tokenColorsByFrequency[i],
                                    tileFrequencies[i], getColumnName(i, titles));
                        }
                        else if (SampleFrequencyCalculator.isNumericalTokenType(tokenTypes[i])) {
                            scheme = new NumericalColorScheme(tiles, i, bounds[i].getMin(),
                                    bounds[i].getMax(), tokenTypes[i], getColumnName(i, titles));
                        }
                        if (scheme != null) {
                            schemes.add(scheme);
                        }
                    }
                    catch (IOException ex) {
                        UiUtils.showExceptionMessage(ex);
                    }
                }
            }
            catch (IOException ex) {
                UiUtils.showExceptionMessage(ex);
            }
            return schemes;
        }


        private Map<SomTile, Map<Object, Double>>[] getTileFrequencies(List<SomTile> tiles,
                int recordLength, TokenType[] tokenTypes) throws IOException {
            @SuppressWarnings("unchecked")
            Map<Object, Double>[][] frequencies = new Map[tiles.size()][];
            for (int i = 0; i < tiles.size(); i++) {
                frequencies[i] = SampleFrequencyCalculator.getSampleFrequencies(
                        tiles.get(i).getTileDataSource(), tokenTypes);
            }
            @SuppressWarnings("unchecked")
            Map<SomTile, Map<Object, Double>>[] tileFrequencies = new Map[recordLength];
            for (int i = 0; i < recordLength; i++) {
                tileFrequencies[i] = new HashMap<>();
                for (int j = 0; j < tiles.size(); j++) {
                    tileFrequencies[i].put(tiles.get(j), frequencies[j][i]);
                }
            }
            return tileFrequencies;
        }
    }
}
